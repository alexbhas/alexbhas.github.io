<?xml version='1.0' encoding='utf-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://alexbhasin.ca/</id>
  <title><![CDATA[Alexander Bhasin]]></title>
  <icon>https://alexbhasin.ca/favicon.png</icon>
  <link href="https://alexbhasin.ca" />
  <link href="https://alexbhasin.ca/atom.xml" rel="self" type="application/atom+xml" />
  <updated>2023-01-07T15:58:50.485Z</updated>
  <author>
    <name><![CDATA[Alexander Bhasin]]></name>
  </author>
  <category term="Projects" scheme="https://alexbhasin.ca/?tags=Projects" />
  <entry>
    <title type="html"><![CDATA[In Depth | Concurrent Fitness Centre System]]></title>
    <link href="https://alexbhasin.ca/concurrent-fitness-centre" />
    <id>https://alexbhasin.ca/concurrent-fitness-centre</id>
    <published>2023-01-02T00:00:00.000Z</published>
    <updated>2023-01-07T00:00:00.000Z</updated>
    <content type="html">
      <![CDATA[<p>For my group’s final project in the ‘Real Time Operating Systems’ class, we created back-end monitoring software for a fitness centre as well as a web application that displays the statistics of the centre.</p><p>The back-end was written in C, making use of the QNX Neutrino operating system and its exclusive libraries. This allowed us to create a monitoring server and many clients that kept track of the different areas of the gym and variables relating to those areas. For example, the tempertaute of the pool and sauna is always tracked, emergencies are tracked, heart rates on cardio machines, etc. The use of an RTOS allows for a very fast response time which would be very beneficial in the environment of a fitness centre where many things are going on at once.</p><p>The front-end was written in JavaScript, and made use of libraries such as Plotly.js to display statistical information about the events occuring in the gym. It displays average temperatures, amounts of emergencies/mishaps, and other information that would be useful to have information for in a fitness centre.</p><p>You can view the software here:<br><a href="https://github.com/alexbhas/RTOS-Fitness-Centre" rel="nofollow noopener noreferrer external" target="_blank">Github Repository</a></p>]]>
    </content>
    <category term="Projects" scheme="https://alexbhasin.ca/?tags=Projects" />
  </entry>
  <entry>
    <title type="html"><![CDATA[In Depth | Dark Mode Colours Tool]]></title>
    <link href="https://alexbhasin.ca/dark-mode-tool" />
    <id>https://alexbhasin.ca/dark-mode-tool</id>
    <published>2023-01-02T00:00:00.000Z</published>
    <updated>2023-01-07T00:00:00.000Z</updated>
    <content type="html">
      <![CDATA[<hr><p>I came up with the idea for this web application while designing a website. I wanted to implement a dark mode theme to the website that only changed the background colour and not the foreground colours. The problem with this though, is that the foreground colour would have to pass the WCAG contrast check for both background colours. As I tried different colours and found none that would work, I started to look for a tool that could provide me with the colours. I could not find anything that useful, so I decided to make the tool myself. </p><p>The tool works by entering two HTML colour codes. Then, the application will generate some of the colours that pass the contrast check for both of the background colours. I say <em>some</em> as there are way too many combinations of colours to check, so I shortened the list by skipping many colours, but still including ones that are relatively close to them. The tool will display all of the colours in a scrollable grid, showing the colour, its code, and rgb value.</p><p>Implementing this took quite some thought. The first thing that needs to be done with the inputted values is converting them from hex to RGB, so that their luminance can be calculated. This is important as the contrast ratio is calculated using the luminance of the two colours. To calculate the luminance, we use the formula <code>L = 0.2126 * R + 0.7152 * G + 0.0722 * B</code> where R, G, and B are modified versions of our original RGB values. You can read more about this here:<a href="https://www.w3.org/TR/WCAG21/#dfn-relative-luminance" rel="nofollow noopener noreferrer external" target="_blank">w3.org</a></p><p>With the values the user entered converted, we then iterate over all of the RGB values, skipping over many values since there are over 16 million possible colours. This does not hinder the results that much in my opinion, as for example if there were thousands of shades of blue that would pass the contrast check, many of them would be indistinguishably different from eachother, and so they could be easily represented by less shades.</p><p>You can view the tool here:<br><a href="https://alexbhasin.ca/dark-mode-colours-tool/" rel="nofollow noopener noreferrer external" target="_blank">Demo</a><br><a href="https://github.com/alexbhas/dark-mode-colours-tool" rel="nofollow noopener noreferrer external" target="_blank">Github Repository</a></p>]]>
    </content>
    <category term="Projects" scheme="https://alexbhasin.ca/?tags=Projects" />
  </entry>
  <entry>
    <title type="html"><![CDATA[In Depth | Game of Life]]></title>
    <link href="https://alexbhasin.ca/life" />
    <id>https://alexbhasin.ca/life</id>
    <published>2023-01-02T00:00:00.000Z</published>
    <updated>2023-01-07T00:00:00.000Z</updated>
    <content type="html">
      <![CDATA[<hr><p>Many years ago, I was introduced to the concept of Conway’s Game of Life. Since then I have been fascinated by how a simple ruleset can create such complex and geometric patterns.</p><p>The Game of Life revolves around cells and their neighbours. This can be easily represented by a grid, where an individual cell’s neighbours are the adjacent vertical, horizontal, and diagonal 8 cells. A cell is either in an alive or dead state, and this state changes depending on if certain conditions are met. Generally, the game will start with a randomly generated grid of alive and dead cells. Every iteration, the grid will update based on how the cells meet their conditions.</p><p>The conditions for each cell are then as follows:  </p><ol><li>Any live cell with less than 2 live neighbours dies</li><li>Any live cell either 2 or 3 live neighbours stays alive</li><li>Any live cell with more than 3 live neighbours dies</li><li>Any dead cell with exactly 3 live neighbours becomes alive</li></ol><p>It is by these simple rules, that the Game of Life is simulated and becomes capable of generating massive and intricate patterns. On a smaller grid size, you can see how a simulation will end, with some groups of cells becoming permenantly alive as they form a pattern that will meet all of the conditions infinitely.</p><p>I decided to implement a simple JavaScript version of it, using the HTML canvas to draw squares that represent the cells. I added functionality to pause and reset the game since on the smaller grid that I have chosen the game can end quite quickly as it updates 10 times per second. </p><p>You can view my Game of Life implementation here:<br><a href="https://alexbhasin.ca/game-of-life/" rel="nofollow noopener noreferrer external" target="_blank">Demo</a><br><a href="https://github.com/alexbhas/game-of-life" rel="nofollow noopener noreferrer external" target="_blank">Github Repository</a></p>]]>
    </content>
    <category term="Projects" scheme="https://alexbhasin.ca/?tags=Projects" />
  </entry>
  <entry>
    <title type="html"><![CDATA[In Depth | OASIS Pro Medical Device Simulator]]></title>
    <link href="https://alexbhasin.ca/oasis" />
    <id>https://alexbhasin.ca/oasis</id>
    <published>2023-01-02T00:00:00.000Z</published>
    <updated>2023-01-07T00:00:00.000Z</updated>
    <content type="html">
      <![CDATA[<hr><p>As the final project for the ‘Object Oriented Software Engineering’ course, my group was tasked with creating a simulation for the OASIS Pro CES medical therapy device. This device is used to administer Microcurrent Electro Therapy to the user. </p><p>To develop this simulation, we made use of the Qt framework and C++. We designed the user interface using Qt’s UI builder and ensured that it accurately represented the device. In order to store the user’s preferences and session history, we made use of an SQLite database.</p><p>Alongside the implementation was thorough documentation that we had created. This included all possible use cases for the device, as well as UML structural and behavioural diagrams and a traceability matrix that included all of the functions of the device.</p><p>You can view the OASIS Pro device here, but our repository is private for academic purposes.<br><a href="https://mindalive.com/products/oasis-pro" rel="nofollow noopener noreferrer external" target="_blank">OASIS Pro</a></p>]]>
    </content>
    <category term="Projects" scheme="https://alexbhasin.ca/?tags=Projects" />
  </entry>
</feed>